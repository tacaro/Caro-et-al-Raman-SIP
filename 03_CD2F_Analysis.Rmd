---
title: "03_CD2F_Analysis"
author: "Tristan Caro"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Setup

## Load libraries

```{r}
library(tidyverse)
library(magrittr)
library(tidyverse)
library(cowplot)
library(latex2exp)
library(ggside)
library(ggsci)
library(ggdist)
```

## Load from cache

```{r}
# Only loading the co-registered dataset using the fitted data

# Co registered datasets
co_registered_fit <- readRDS("cache/co_registered_fitted.RDS")

# Area data
cd_pc_data_fitted <- readRDS("cache/area_data.RDS")

# Fitted xy data
fit_data <- readRDS("cache/fit_data.RDS")

# Fitting parameter data
fitted_xy_data <- readRDS("cache/peak_data_xy.RDS")
```

## Load from source

```{r}
calculate_growth <- source("source/Calculate_Growth.R")
```


# Proxy generation
```{r}
proxy_data <- broom::tidy(lm(data = co_registered_fit, `CD%`  ~ at2H_percent_dtc))
proxy_y_int <- proxy_data %>% 
  filter(term == "(Intercept)") %>%
  select(estimate) %>% 
  pull()

proxy_slope <- proxy_data %>% 
  filter(term == "at2H_percent_dtc") %>% 
  select(estimate) %>% 
  pull()
```

# Proxy generation - SRB
```{r}
proxy_data_SRB <- broom::tidy(lm(
  data = co_registered_fit %>% filter(organism == "T. hydrogeniphilus"), 
  `CD%`  ~ at2H_percent_dtc))
proxy_y_int_SRB <- proxy_data_SRB %>% 
  filter(term == "(Intercept)") %>%
  select(estimate) %>% 
  pull()

proxy_slope_SRB <- proxy_data_SRB %>% 
  filter(term == "at2H_percent_dtc") %>% 
  select(estimate) %>% 
  pull()
```

# Proxy generation - Mb
```{r}
proxy_data_Mb <- broom::tidy(lm(
  data = co_registered_fit %>% filter(organism == "M. NSHQ14"), 
  `CD%`  ~ at2H_percent_dtc))
proxy_y_int_Mb <- proxy_data_Mb %>% 
  filter(term == "(Intercept)") %>%
  select(estimate) %>% 
  pull()

proxy_slope_Mb <- proxy_data_Mb %>% 
  filter(term == "at2H_percent_dtc") %>% 
  select(estimate) %>% 
  pull()
```

## Quickplot the proxy fit

```{r}
co_registered_fit %>% 
  ggplot(
    aes(
      x = at2H_percent_dtc,
      y = `CD%`
    )
  ) +
  geom_point() +
  geom_smooth(
    method = "lm",
    formula = "y ~ x",
    se = FALSE,
    level = 0.99, # 99% confidence interval
    color = "red"
  ) +
  geom_abline(slope = 1, linetype = "dashed") +
  coord_cartesian(xlim = c(0,25), ylim =  c(0,45)) +
  labs(
    title = paste0("y = ", round(proxy_slope, 4), "x + ", round(proxy_y_int, 4))
  ) +
  theme_classic()
```

# Generate test dataset

```{r}
test_data <- tibble(
  experiment = "A",
  a = 1, # assimilation efficiency assumed to be 1
  f_l = 30, # label strenght is 30 atom % D2O
  t = 60, # incubation time is 60 days
  f_0 = 0.0000000001, # f0, biomass at t0, assumed to be natural abundance of the deuterium isotope
  f_t = abs(rnorm(
    n = 5000, # number of cells measured
    mean = 10,
    sd = 4
    ))
) %>% 
  mutate(
    f_t = case_when(
      f_t > 30 ~ 30,
      TRUE ~ f_t
    )
  ) %>% 
  mutate(
    u_d = calculate_turnover(
      a = a,
      FL = f_l,
      t = t,
      F0 = f_0,
      FT = f_t
    )
  )
```

### Inspect the f_t distribution

```{r}
# Inspect the distribution
test_data %>% 
  ggplot(
    aes(
      x = f_t
    )
  ) +
  geom_histogram(bins = 100) +
  theme_classic()
```

### Inspect the turnover rates

```{r}
# Inspect the µ
test_data %>% 
  ggplot(
    aes(
      x = u_d
    )
  ) +
  geom_histogram(bins = 100) +
  labs(
    x = latex2exp::TeX("Turnover rate ($d^{-1}$)")
  ) +
  theme_classic()
```

### Apply the proxy to the turnover rates

```{r}
test_data_proxied <- test_data %>% 
  mutate(
    f_t_raman = f_t * proxy_slope,
    f_t_nanoSIMS = f_t / proxy_slope,
    u_d_raman = calculate_turnover(
      a = a,
      FL = f_l,
      t = t,
      F0 = f_0,
      FT = f_t_raman
      ),
    u_d_nanoSIMS = calculate_turnover(
      a = a,
      FL = f_l,
      t = t,
      F0 = f_0,
      FT = f_t_nanoSIMS
      )
    )
```

### Inspect the distribution of f_t

```{r}
test_data_proxied %>% 
  pivot_longer(
    cols = c(f_t, f_t_raman, f_t_nanoSIMS),
    values_to = "f_t",
    names_to = "type"
    ) %>% 
  ggplot(
    aes(
      x = f_t,
      fill = type
    )
  ) +
  stat_halfeye(
    alpha = 0.5
  )
```

### Inspect the distribution of µ

```{r}
test_data_proxied %>% 
  pivot_longer(
    cols = c(u_d, u_d_nanoSIMS),
    values_to = "u_d",
    names_to = "type"
    ) %>% 
  ggplot(
    aes(
      x = u_d,
      fill = type
    )
  ) +
  stat_halfeye(
    alpha = 0.5
  )
```

```{r}
test_data_proxied %>% 
  ggplot(
    aes(
      x = f_t,
      y = f_t_raman
    )
  ) +
  geom_point()
```

```{r}
test_data_proxied %>%
  pivot_longer(cols = c(f_t, f_t_raman),
               names_to = "type",
               values_to = "2F") %>% 
  pivot_longer(
    cols = c(f_0, `2F`),
    names_to = "timepoint",
    values_to = "FT"
  ) %>% 
  mutate(
    dt = case_when(
      timepoint == "f_0" ~ 0,
      timepoint == "2F" ~ 60
    )
  ) %>%
  ggplot(
    aes(x = dt,
        y = FT,
        color = type)
  ) +
  geom_point() +
  geom_line(alpha = 0.5)
```


# CD-FL and 2F-FL comparison

```{r}
cdfl_model <- broom::tidy(
  lm(
    data = co_registered_fit %>% 
      filter(f_l < 40), 
    `CD%`  ~ f_l
    )
  )

f2fl_model <- broom::tidy(
  lm(
    data = co_registered_fit %>% 
      filter(f_l < 40),
    at2H_percent_dtc ~ f_l
  )
)
```

# Error analysis

```{r}
co_registered_fit_w_se <- co_registered_fit %>% 
  group_by(f_l) %>% 
  summarize(
    mn_cd = mean(`CD%`, na.rm = TRUE),
    mn_2f = mean(at2H_percent_dtc, na.rm = TRUE),
    se_cd = sd(`CD%`, na.rm = TRUE),
    se_2f = sd(at2H_percent_dtc, na.rm = TRUE)
  )
co_registered_fit_w_se

p_co_registered_fit_w_se <- co_registered_fit_w_se %>% 
  ggplot(
    aes(
      x = mn_2f,
      y = mn_cd,
      color = as.factor(f_l),
      shape = organism
    )
  ) +
  geom_point(
    size = 3,
  ) +
  geom_linerange(
    aes(
      ymin = mn_cd - (0.5* se_cd),
      ymax = mn_cd + (0.5* se_cd)
    ),
    linewidth = 1
  ) +
  geom_linerange(
    aes(
      xmin = mn_2f - (0.5 * se_2f),
      xmax = mn_2f + (0.5 * se_2f)
    ),
    linewidth = 1
  ) +
  scale_color_viridis_d(
    option = "magma",
    begin = 0.2,
    end = 0.9
  ) +
  labs(
    x = "Mean 2F (NanoSIMS)",
    y = "Mean CD% (Raman)",
    color = "Label Strength (%)"
  ) +
  theme_classic()

p_co_registered_fit_w_se_inset <- co_registered_fit_w_se %>% 
  ggplot(
    aes(
      x = mn_2f,
      y = mn_cd,
      color = as.factor(f_l)
    )
  ) +
  geom_point(
    size = 3,
    shape = 1
  ) +
  geom_linerange(
    aes(
      ymin = mn_cd - (0.5* se_cd),
      ymax = mn_cd + (0.5* se_cd)
    ),
    linewidth = 1
  ) +
  geom_linerange(
    aes(
      xmin = mn_2f - (0.5 * se_2f),
      xmax = mn_2f + (0.5 * se_2f)
    ),
    linewidth = 1
  ) +
  scale_color_viridis_d(
    option = "magma",
    begin = 0.2,
    end = 0.9
  ) +
  coord_cartesian(xlim = c(0,0.05), ylim = c(0, 5)) +
  labs(
    x = "",
    y = "",
    color = ""
  ) +
  theme_classic()
p_co_registered_fit_w_se_inset
```

### Track Standard Error
```{r}
co_registered_fit_w_se %>% 
  pivot_longer(
    cols = c(se_cd, se_2f),
    names_to = "Method",
    values_to = "se"
  ) %>% 
  ggplot(
    aes(
      x = f_l,
      y = se,
      color = Method,
      fill = Method,
      linetype = organism
    )
  ) + geom_line()
```


### Identify Raman/nanoSIMS measurement error

```{r}
raman_standard_error <- co_registered_fit_w_se %>% 
  filter(f_l == 0) %>% 
  select(se_cd) %>% 
  pull()

nanoSIMS_standard_error <- co_registered_fit_w_se %>% 
  filter(f_l == 0) %>% 
  select(se_2f) %>% 
  pull()
```

```{r}
calculate_turnover(
  a = 1,
  FT = raman_standard_error,
  F0 = 0,
  FL = 30,
  t = 7
)

# Multiply the raman standard error by 2 to assume that 2SD is required to be above BG noise
error_u_d <- tibble(
  a = 0.7,
  error_raman = 2 * raman_standard_error,
  error_nanoSIMS = 2* nanoSIMS_standard_error,
  F0 = 0,
  FL = seq(5,50, by = 1),
  t = 7,
  # Calculate detection limit in turnover (d^-1)
  DLR_u_d = calculate_turnover(
    a = a,
    FT = error_raman,
    FL = FL,
    t = t,
    F0 = F0
  ),
  DLN_u_d = calculate_turnover(
    a = a,
    FT = error_nanoSIMS,
    FL = FL,
    t = t,
    F0 = F0
  )
) %>% 
  pivot_longer(
    cols = c(DLR_u_d, DLN_u_d),
    values_to = "DL_u_d",
    names_to = "Method"
  )

error_u_d %>% 
  ggplot(
    aes(
      x = FL, 
      y = DL_u_d, 
      color = Method
    )
  ) +
  geom_line()
```

```{r}
error_u_d_var <- tibble(
  FL = seq(1, 50, by = 1),
  t = seq(1, 50, by = 1)
  ) %>% 
  expand(FL, t) %>% 
  mutate(
    a = 0.7,
    F0 = 0.0000000000000001,
    error_raman = (2 * raman_standard_error),
    error_nanoSIMS = (2 * nanoSIMS_standard_error),
    DLR_u_d = calculate_turnover(
      a = a,
      FT = error_raman,
      FL = FL,
      t = t,
      F0 = F0
    ),
    DLN_u_d = calculate_turnover(
      a = a,
      FT = error_nanoSIMS,
      FL = FL,
      t = t,
      F0 = F0
    )
) %>% 
  pivot_longer(
    cols = c(DLR_u_d, DLN_u_d),
    values_to = "DL_u_d",
    names_to = "Method"
  )

p_error_u_d_var <- error_u_d_var%>% 
  ggplot(
    aes(
      x = FL, 
      y = DL_u_d, 
      color = t
    )
  ) +
  geom_point() +
  facet_wrap(vars(Method), scales = "free") +
  scale_y_log10()
plotly::ggplotly(p_error_u_d_var)
```

